Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import cv2\r\nimport numpy as np\r\nfrom colorsys import hsv_to_rgb\r\n\r\nfrom colorsys import hsv_to_rgb\r\n\r\ndef channel_selection(img):\r\n    channel_r = img[:, :, 0]\r\n    channel_g = img[:, :, 1]\r\n    channel_b = img[:, :, 2]\r\n\r\n    means = [\r\n        np.mean(channel_r),\r\n        np.mean(channel_g),\r\n        np.mean(channel_b)\r\n    ]\r\n\r\n    if min(means) == means[0]:\r\n        return channel_r\r\n    elif min(means) == means[1]:\r\n        return channel_g\r\n    else:\r\n        return channel_b\r\n\r\n\r\nclass Image:\r\n    def __init__(self, _raw):\r\n        self.raw = _raw\r\n        self.contoured = None\r\n\r\n    # @property\r\n    # def width(self):\r\n    #     return self.raw.shape[0]\r\n    #\r\n    # @property\r\n    # def height(self):\r\n    #     return self.raw.shape[1]\r\n\r\n    @property\r\n    def preprocessed(self):\r\n        kernel = np.ones((4, 4), np.uint8)\r\n\r\n        img = cv2.bilateralFilter(self.raw, 25, 75, 75)\r\n        img = channel_selection(img)\r\n        ret, img = cv2.threshold(img, np.mean(img) / 1.2, 255, cv2.THRESH_BINARY)\r\n        # img = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 19, 3)\r\n        # img = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)\r\n        img = cv2.erode(img, kernel, iterations=2)\r\n        img = cv2.dilate(img, kernel, iterations=1)\r\n        img = cv2.bitwise_not(img)\r\n        cv2.imshow('preprocessing', img)\r\n\r\n        return img\r\n\r\n\r\nclass Frame(Image):\r\n    def __init__(self, _raw):\r\n        super().__init__(_raw)\r\n        self.boards = []\r\n\r\n    def find_boards(self):\r\n        contours, _ = cv2.findContours(self.preprocessed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n\r\n        for i, contour in enumerate(contours):\r\n            a = np.min(contour[:, :, 1])\r\n            b = np.max(contour[:, :, 1])\r\n            c = np.min(contour[:, :, 0])\r\n            d = np.max(contour[:, :, 0])\r\n\r\n            cv2.imshow(\"1 Board\", self.raw[a:b, c:d])\r\n\r\n            cv2.drawContours(self.contoured, [contour], -1, np.array(hsv_to_rgb(1 / len(contours) * j, 1, 1)) * 255.0, 5)\r\n            cv2.imshow(\"Boards\", self.raw)\r\n            board = Board(self.raw[a:b, c:d])\r\n            self.boards.append(board)\r\n\r\n\r\nclass Board(Image):\r\n    def __init__(self, _raw):\r\n        super().__init__(_raw)\r\n        self.tiles = []\r\n\r\n    def find_tiles(board, board_tmp):\r\n        contours, hierarchy = cv2.findContours(board_tmp, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\r\n\r\n        # print(hierarchy)\r\n        contours_areas = [cv2.contourArea(contour) for contour in contours]\r\n        contours_areas = sorted(contours_areas, reverse=True)\r\n        tiles = contours_areas[1:10]\r\n\r\n        for i, contour in enumerate(contours):\r\n            area = cv2.contourArea(contour)\r\n\r\n            if area in tiles:\r\n                peri = cv2.arcLength(contour, True)\r\n                approx = cv2.approxPolyDP(contour, 0.04 * peri, True)\r\n                (x, y, w, h) = cv2.boundingRect(approx)\r\n                cv2.drawContours(board, [contour], -1, np.array(hsv_to_rgb(i / len(contours), 1, 1)) * 255.0, 5)\r\n                cv2.putText(board, str(i), (x + 10, y + 10), cv2.FONT_HERSHEY_SIMPLEX, 1, np.array(hsv_to_rgb(i / len(contours), 1, 1)) * 255.0, 2)\r\n\r\n            # shape = \"unidentified\"\r\n            # peri = cv2.arcLength(contour, True)\r\n            # approx = cv2.approxPolyDP(contour, 0.04 * peri, True)\r\n            #\r\n            # if len(approx) == 4:\r\n            #     # compute the bounding box of the contour and use the\r\n            #     # bounding box to compute the aspect ratio\r\n            #     (x, y, w, h) = cv2.boundingRect(approx)\r\n            #     ar = w / float(h)\r\n            #     # a square will have an aspect ratio that is approximately\r\n            #     # equal to one, otherwise, the shape is a rectangle\r\n            #     shape = \"square\" if ar >= 0.95 and ar <= 1.05 else \"rectangle\"\r\n            #     print(shape)\r\n\r\n\r\n        cv2.imshow(\"img board\", board)\r\n\r\n\r\ndef main(url):\r\n    while True:\r\n        success, raw = cv2.VideoCapture(url).read()\r\n\r\n        if not success:\r\n            break\r\n\r\n        frame = Frame(raw)\r\n        key   = cv2.waitKey(1)\r\n\r\n        cv2.imshow(\"Tic tac toe\", frame.raw)\r\n\r\n        if key == 27:\r\n            break\r\n        elif key == 13:\r\n            cv2.imshow(\"Frame\", frame.preprocessed)\r\n            frame.boards\r\n\r\n    cv2.destroyAllWindows()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    address = \"192.168.1.85\"\r\n    port    = \"8080\"\r\n\r\n    main(f\"https://{address}:{port}/video\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- main.py	(revision 50d56995c69919c03b197992f3997351ff3175a7)
+++ main.py	(date 1638361874746)
@@ -69,7 +69,7 @@
 
             cv2.imshow("1 Board", self.raw[a:b, c:d])
 
-            cv2.drawContours(self.contoured, [contour], -1, np.array(hsv_to_rgb(1 / len(contours) * j, 1, 1)) * 255.0, 5)
+            cv2.drawContours(self.contoured, [contour], -1, np.array(hsv_to_rgb(1 / len(contours) * i, 1, 1)) * 255.0, 5)
             cv2.imshow("Boards", self.raw)
             board = Board(self.raw[a:b, c:d])
             self.boards.append(board)
